\section{Тест производительности}

Тест производительности сравнивает реализованную сортировку подсчетом с алгоритмом \texttt{std::stable\_sort} из стандартной библиотеки C++.

\subsection{Методика тестирования}

Для тестирования использовались данные со следующими характеристиками:
\begin{itemize}
    \item Количество элементов: от 5 до 1\,000\,000
    \item Диапазон ключей: от 000000 до 999999 (6 цифр)
    \item Каждый элемент содержит 32-битный ключ (\texttt{id}) и 64-битное значение (\texttt{value})
    \item Ключи генерируются случайным образом из равномерного распределения
\end{itemize}

Замеры времени производились с помощью \texttt{std::chrono::system\_clock} с точностью до микросекунд. Для каждого размера входных данных создавался отдельный тестовый файл с помощью генератора на Python.

\subsection{Результаты измерений}

\begin{table}[h]
\centering
\begin{tabular}{|r|r|r|r|}
\hline
\textbf{N} & \textbf{Counting Sort (мкс)} & \textbf{STL Sort (мкс)} & \textbf{Ускорение} \\
\hline
5 & 6\,013 & 1 & 0.00x \\
50 & 8\,812 & 4 & 0.00x \\
100 & 8\,623 & 9 & 0.00x \\
1\,000 & 9\,554 & 88 & 0.01x \\
2\,000 & 9\,211 & 248 & 0.03x \\
3\,000 & 9\,307 & 288 & 0.03x \\
5\,000 & 9\,369 & 572 & 0.06x \\
10\,000 & 9\,268 & 1\,025 & 0.11x \\
20\,000 & 9\,853 & 2\,615 & 0.27x \\
25\,000 & 9\,894 & 3\,545 & 0.36x \\
50\,000 & 10\,431 & 6\,250 & 0.60x \\
100\,000 & 12\,149 & 15\,859 & 1.31x \\
1\,000\,000 & 37\,944 & 165\,626 & 4.37x \\
\hline
\end{tabular}
\caption{Результаты сравнения производительности алгоритмов сортировки}
\label{tab:benchmark}
\end{table}

\subsection{Анализ результатов}

Из таблицы~\ref{tab:benchmark} и графика (рис.~\ref{fig:benchmark}) видно, что производительность сортировки подсчетом существенно зависит от размера входных данных:

\begin{itemize}
    \item \textbf{Малые размеры (n < 10\,000)}: Сортировка подсчетом проигрывает \texttt{std::stable\_sort}. Это объясняется накладными расходами на создание вспомогательных массивов (массив счетчиков размером 1\,000\,000 элементов) и поиск минимального/максимального элемента.
    
    \item \textbf{Средние размеры (10\,000 ≤ n < 100\,000)}: Алгоритмы показывают сопоставимую производительность. При $n = 100\,000$ сортировка подсчетом начинает обгонять STL сортировку (ускорение 1.31x).
    
    \item \textbf{Большие размеры (n ≥ 100\,000)}: Сортировка подсчетом значительно быстрее. На миллионе элементов ускорение составляет 4.37x.
\end{itemize}

\begin{figure}[h]
\centering
\includegraphics[width=\textwidth]{benchmark_results.png}
\caption{Сравнение производительности алгоритмов сортировки}
\label{fig:benchmark}
\end{figure}

\subsection{Выводы}

Асимптотическая сложность алгоритмов:
\begin{itemize}
    \item Сортировка подсчетом: $O(n + k)$, где $k = 1\,000\,000$ — диапазон ключей
    \item \texttt{std::stable\_sort}: $O(n \log n)$
\end{itemize}

При малых $n$ доминирует слагаемое $k$, что делает сортировку подсчетом неэффективной. Однако с ростом $n$ линейная зависимость от количества элементов дает преимущество перед логарифмической сложностью STL алгоритма.

Точка равновесия находится примерно при $n \approx 100\,000$ элементов. При больших объемах данных сортировка подсчетом демонстрирует существенное преимущество, что подтверждает теоретические оценки сложности.

\pagebreak
